
#include <iostream>

int main(int argc, char* argv[])
{
	// упражнение 2.21
	int i = 0;
	//double& dp = &i; ошибка компиляции так как тип указателя должен соответствовать типу объкта на который ссылается указатель
	//int *ip = i; такая же ошибка
	int *p = &i; // всё ок p будет ссылаться на i, значение p - адресс i

	// упражнение 2.22
	if (p)		// условие истинно если p ссылается на что-либо
	if (*p)		// условие истинно если i не равно 0 (p ссылается i)
		std::cout << ' ';

	// упражнение 2.23
	// из простых проверок на валидность указателя есть только проверка на не нулевой указатель (nullptr)

	// упражнение 2.24
	// тот же случай что и в упражнении 2.21 - не соответсвие типов
	// void указатель может ссылаться на луюбой участок памяти, но не может быть разыменован

	// упражнение 2.25
	//(a)
	//int *ip, &r = ip; липман чудит. Это говно даже не скомпилится
	//(b)
	int i24, *ip = 0; //i24 - мусор, ip - нулевой указатель на int
	//(c)
	int *ip1, *ip2; // нулевые указатели

	// упражнение 2.26
	//const int buf; ошибка - константные объекты должны быть инициализировваны при объявлении
	int cnt = 0; //ok
	const int sz = cnt; //ok
	++cnt; //ok
	//++sz; // ошибка - нельзя изменять const объекты

	// упражнение 2.27
	//int i = -1, &r = 0; i=-1 - ok, &r=0 - ошибка - ссылка должна быть инициализирована не вреемнным объектом
	int i2;
	int *const p2 = &i2; // ok - константный указатель на неконстантный i2
	const int i27 = -1, &r = 0; // ok - i27 - константа = -1, r - объект типа int = 0
	const int *const p3 = &i2; // ok - константный указатель на константные данные
	const int *p1 = &i2; // ok - некостантный указатель на константные данные
	//const int &const r2; // ошибка - ссытлка не инициализирована
	const int i3 = i, &r2 = i; // ok - i3 - int = i, r2 - const int& ссылающаяся на i

	// упражнение 2.28
	//int i, *const cp; // объект int, константный указатель на не константные даннные
	//int *p1, *const p2; // указатель на int, константный указатель на не константные даннные
	//const int ic, &r = ic; // константный int объект, не константная ссылка на константный int
	//const int *const p3; // констнтный указатель на константный int
	//const int *p; // неконстантный указатель на константный int

	// упражнение 2.29
	//i = ic; //i присваивается значение ic
	//p1 = p3; //p1 станет указывать на туже область что и p3
	//p1 = &ic; // p1 станет указывать на ic
	//p3 = &ic; // невозможно изменить константный указатель
	//p2 = p1; // невозможно изменить константный указатель
	//ic = *p3; // ic нельзя изменять, так как ic константа

	// упражнение 2.30
	const int v2 = 0; // const нижнего уровня
	int v1 = v2; // const нет
	int *p130 = &v1, &r1 = v1; //const нет
	const int *p230 = &v2, *const p330 = &i, &r230 = v2; //p2 - const нижнего уровня, p3 - const двух уровней, r3 - const нижнего уровня

	// упражнение 2.31
	//r1 = v2; // const нижнего уровня 
	//p1 = p2; // нельзя так как p2 имеет const нижненго уровня, когда p1 
	//p2 = p1; // p1 преобразуется и в const int*
	//p1 = p3; // p3 имеет const нижнего уровня, в то время как p1 нет, что явл ошибкой
	//p2 = p3; // p3 имеет const вернего уровня, который опускается

	// упражнение 2.32
	//int null = 0, *p32 = null; // ошибка
	//Поавильно
	// a -- int null = 0, *p32 = &null;
	// b -- int null = 0, *p32 = 0;
	// c -- int null = 0, *p32 = NULL;
	// d -- int null = 0, *p32 = nullptr;

	return 0;
}
